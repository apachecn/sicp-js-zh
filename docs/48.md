# 3模块化，对象和状态

> 译者： [https://sicp.comp.nus.edu.sg/chapters/47](https://sicp.comp.nus.edu.sg/chapters/47)

 <chapter>> ![%5Cdef%5Caal%7B%5Calpha%7B%5Craise%201pt%5Chbox%7B%5Chskip%20-4pt%7B%5Cchar'47%7D%7D%7D%7DM%5Cepsilon%5Ctau%5Calpha%5Cbeta%5Cacute%7B%5Calpha%7D%5Clambda%5Clambda%20o%20%5Cnu%5C%0A%20%20%20%20%E1%BC%80%5Cnu%5Calpha%5Cpi%5Calpha%5Cacute%7B%5Cupsilon%7D%5Cepsilon%5Ctau%5Calpha%5Ciota](../Images/facb1f521460f466cee020c8afeaf58f.jpg)
> （即使它发生变化，它仍然保持静止。）Heraclitus

> 加上零钱，再加上c'est lamême。Alphonse Karr

<chaptercontent></chaptercontent>

前面的章节介绍了制作程序的基本元素。 我们看到了原始函数和原始数据是如何组合在一起以构造复合实体的，并且我们了解到抽象对于帮助我们应对大型系统的复杂性至关重要。 但是这些工具不足以设计程序。 有效的程序综合还需要组织原则，这些原则可以指导我们制定程序的总体设计。 特别是，我们需要一些策略来帮助我们构建大型系统，使它们成为_模块化_，也就是说，可以自然地将&lt;quote&gt;划分为&lt;/quote&gt;成为可以分别开发和 保持。

一种特别适用于构建物理系统模型的程序的强大设计策略是，将我们程序的结构基于要建模的系统的结构。 对于系统中的每个对象，我们构造一个相应的计算对象。 对于每个系统动作，我们在计算模型中定义一个符号运算。 我们希望使用这种策略是希望扩展模型以适应新对象或新动作，而无需对程序进行任何战略更改，只需添加这些对象或动作的新符号类似物即可。 如果我们在系统组织中获得成功，那么要添加新功能或调试旧功能，我们将只能在系统的本地化部分上工作。

因此，在很大程度上，我们组织大型程序的方式取决于我们对要建模的系统的感知。 在本章中，我们将研究两种显着的组织策略，这些策略是由于系统结构的两种相当不同的世界观产生的。 第一个组织策略专注于_对象_，将大型系统视为行为随时间变化的不同对象的集合。 另一种组织策略集中在系统中流动的_信息流_上，就像电气工程师查看信号处理系统一样。

基于对象的方法和流处理方法都在编程中引起了重大的语言问题。 对于对象，我们必须关注计算对象如何更改并保持其身份。 这将迫使我们放弃旧的计算替代模型（ [1.1.5](7) ），而转向更具机械性但在理论上不太容易处理的_环境模型_ 。 处理对象，更改和标识的困难是我们计算模型中需要应对时间的根本结果。 当我们允许并发执行程序时，这些困难会变得更大。 当我们将模型中的模拟时间与评估期间计算机中发生的事件的顺序脱钩时，可以最充分地利用流方法。 我们将使用称为_延迟评估_的技术来完成此操作。

<chaptercontent></chaptercontent></chapter>