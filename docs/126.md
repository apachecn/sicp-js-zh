# 参考文献

> 译者： [https://sicp.comp.nus.edu.sg/chapters/125](https://sicp.comp.nus.edu.sg/chapters/125)

<references><reference>Abelson, Harold, Andrew Berlin, Jacob Katzenelson, William McAllister, Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992\. The Supercomputer Toolkit: A general framework for special-purpose computing. _International Journal of High-Speed Electronics_ 3(3):337-361.</reference> <reference>Allen, John. 1978\. _Anatomy of Lisp._ New York: McGraw-Hill.</reference> <reference>ANSI X3.226-1994\. _American National Standard for Information Systems—Programming Language—Common Lisp._</reference> <reference>Appel, Andrew W. 1987\. Garbage collection can be faster than stack allocation. _Information Processing Letters_ 25(4):275-279.</reference> <reference>Backus, John. 1978\. Can programming be liberated from the von Neumann style? _Communications of the ACM_ 21(8):613-641.</reference> <reference>Baker, Henry G., Jr. 1978\. List processing in real time on a serial computer. _Communications of the ACM_ 21(4):280-293.</reference> <reference>Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and Daniel Weise. 1982\. The Scheme-81 architecture—System and chip. In _Proceedings of the MIT Conference on Advanced Research in VLSI,_ edited by Paul Penfield, Jr. Dedham, MA: Artech House.</reference> <reference>Borning, Alan. 1977\. ThingLab—An object-oriented system for building simulations using constraints. In _Proceedings of the 5th International Joint Conference on Artificial Intelligence._</reference> <reference>Borodin, Alan, and Ian Munro. 1975\. _The Computational Complexity of Algebraic and Numeric Problems._ New York: American Elsevier.</reference> <reference>Chaitin, Gregory J. 1975\. Randomness and mathematical proof. _Scientific American_ 232(5):47-52.</reference> <reference>Church, Alonzo. 1941\. _The Calculi of Lambda-Conversion._ Princeton, N.J.: Princeton University Press.</reference> <reference>Clark, Keith L. 1978\. Negation as failure. In _Logic and Data Bases._ New York: Plenum Press, pp. 293-322.</reference> <reference>Clinger, William. 1982\. Nondeterministic call by need is neither lazy nor by name. In _Proceedings of the ACM Symposium on Lisp and Functional Programming,_ pp. 226-234.</reference> <reference>Clinger, William, and Jonathan Rees. 1991\. Macros that work. In _Proceedings of the 1991 ACM Conference on Principles of Programming Languages,_ pp. 155-162.</reference> <reference>Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel. 1973\. Un système de communication homme-machine en français. Technical report, Groupe Intelligence Artificielle, Université d'Aix Marseille, Luminy.</reference> <reference>Cormen, Thomas, Charles Leiserson, and Ronald Rivest. 1990\. _Introduction to Algorithms._ Cambridge, MA: MIT Press.</reference> <reference>Darlington, John, Peter Henderson, and David Turner. 1982\. _Functional Programming and Its Applications._ New York: Cambridge University Press.</reference> <reference>Dijkstra, Edsger W. 1968a. The structure of the <quote>THE</quote> multiprogramming system. _Communications of the ACM_ 11(5):341-346.</reference> <reference>Dijkstra, Edsger W. 1968b. Cooperating sequential processes. In _Programming Languages_, edited by F. Genuys. New York: Academic Press, pp. 43-112.</reference> <reference>Dinesman, Howard P. 1968\. _Superior Mathematical Puzzles_. New York: Simon and Schuster.</reference> <reference>deKleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman. 1977. AMORD: Explicit control of reasoning. In _Proceedings of the ACM Symposium on Artificial Intelligence and Programming Languages,_ pp. 116-125.</reference> <reference>Doyle, Jon. 1979\. A truth maintenance system. _Artificial Intelligence_ 12:231-272.</reference> <reference>Feigenbaum, Edward, and Howard Shrobe. 1993\. The Japanese National Fifth Generation Project: Introduction, survey, and evaluation. In _Future Generation Computer Systems,_ vol. 9, pp. 105-117.</reference> <reference>Feeley, Marc. 1986\. Deux approches à l'implantation du language Scheme. Masters thesis, Université de Montréal.</reference> <reference>Feeley, Marc and Guy Lapalme. 1987\. Using closures for code generation. _Journal of Computer Languages_ 12(1):47-66.</reference> <reference>Feller, William. 1957\. _An Introduction to Probability Theory and Its Applications,_ volume 1\. New York: John Wiley & Sons.</reference> <reference>Fenichel, R., and J. Yochelson. 1969\. A Lisp garbage collector for virtual memory computer systems. _Communications of the ACM_ 12(11):611-612.</reference> <reference>Floyd, Robert. 1967\. Nondeterministic algorithms. _JACM,_ 14(4):636-644.</reference> <reference>Forbus, Kenneth D., and Johan deKleer. 1993\. _Building Problem Solvers._ Cambridge, MA: MIT Press.</reference> <reference>Friedman, Daniel P., and David S. Wise. 1976\. CONS should not evaluate its arguments. In _Automata, Languages, and Programming: Third International Colloquium,_ edited by S. Michaelson and R. Milner, pp. 257-284.</reference> <reference>Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992. _Essentials of Programming Languages._ Cambridge, MA: MIT Press/McGraw-Hill.</reference> <reference>Gabriel, Richard P. 1988\. The Why of _Y_. _Lisp Pointers_ 2(2):15-25.</reference> <reference>Goldberg, Adele, and David Robson. 1983\. _Smalltalk-80: The Language and Its Implementation._ Reading, MA: Addison-Wesley.</reference> <reference>Gordon, Michael, Robin Milner, and Christopher Wadsworth. 1979\. _Edinburgh LCF._ Lecture Notes in Computer Science, volume 78\. New York: Springer-Verlag.</reference> <reference>Gray, Jim, and Andreas Reuter. 1993\. _Transaction Processing: Concepts and Models._ San Mateo, CA: Morgan-Kaufman.</reference> <reference>Green, Cordell. 1969\. Application of theorem proving to problem solving. In _Proceedings of the International Joint Conference on Artificial Intelligence,_ pp. 219-240.</reference> <reference>Green, Cordell, and Bertram Raphael. 1968\. The use of theorem-proving techniques in question-answering systems. In _Proceedings of the ACM National Conference,_ pp. 169-181.</reference> <reference>Griss, Martin L. 1981\. Portable Standard Lisp, a brief overview. Utah Symbolic Computation Group Operating Note 58, University of Utah.</reference> <reference>Guttag, John V. 1977\. Abstract data types and the development of data structures. _Communications of the ACM_ 20(6):397-404.</reference> <reference>Hamming, Richard W. 1980\. _Coding and Information Theory._ Englewood Cliffs, N.J.: Prentice-Hall.</reference> <reference>Hanson, Christopher P. 1990\. Efficient stack allocation for tail-recursive languages. In _Proceedings of ACM Conference on Lisp and Functional Programming,_ pp. 106-118.</reference> <reference>Hanson, Christopher P. 1991\. A syntactic closures macro facility. _Lisp Pointers,_ 4(3).</reference> <reference>Hardy, Godfrey H. 1921\. Srinivasa Ramanujan. _Proceedings of the London Mathematical Society_ XIX(2).</reference> <reference>Hardy, Godfrey H., and E. M. Wright. 1960\. _An Introduction to the Theory of Numbers._ 4th edition. New York: Oxford University Press.</reference> <reference>Havender, J. 1968\. Avoiding deadlocks in multi-tasking systems. _IBM Systems Journal_ 7(2):74-84.</reference> <reference>Hearn, Anthony C. 1969\. Standard Lisp. Technical report AIM-90, Artificial Intelligence Project, Stanford University.</reference> <reference>Henderson, Peter. 1980\. _Functional Programming: Application and Implementation._ Englewood Cliffs, N.J.: Prentice-Hall.</reference> <reference>Henderson. Peter. 1982\. Functional Geometry. In _Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming,_ pp. 179-187.</reference> <reference>Hewitt, Carl E. 1969\. PLANNER: A language for proving theorems in robots. In _Proceedings of the International Joint Conference on Artificial Intelligence,_ pp. 295-301.</reference> <reference>Hewitt, Carl E. 1977\. Viewing control structures as patterns of passing messages. _Journal of Artificial Intelligence_ 8(3):323-364.</reference> <reference>Hoare, C. A. R. 1972\. Proof of correctness of data representations. _Acta Informatica_ 1(1).</reference> <reference>Hodges, Andrew. 1983\. _Alan Turing: The Enigma._ New York: Simon and Schuster.</reference> <reference>Hofstadter, Douglas R. 1979\. _Gödel, Escher, Bach: An Eternal Golden Braid._ New York: Basic Books.</reference> <reference>Hughes, R. J. M. 1990\. Why functional programming matters. In _Research Topics in Functional Programming_, edited by David Turner. Reading, MA: Addison-Wesley, pp. 17-42.</reference> <reference>IEEE Std 1178-1990\. 1990\. _IEEE Standard for the Scheme Programming Language._</reference> <reference>Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig; assisted by M. Lind, Herbert Kanner, and Robert Floyd. 1960\. THUNKS: A way of compiling procedure statements, with some comments on procedure declarations. Unpublished manuscript. (Also, private communication from Wallace Feurzeig.)</reference> <reference>Kaldewaij, Anne. 1990\. _Programming: The Derivation of Algorithms._ New York: Prentice-Hall.</reference> <reference>Kohlbecker, Eugene Edmund, Jr. 1986\. Syntactic extensions in the programming language Lisp. Ph.D. thesis, Indiana University.</reference> <reference>Konopasek, Milos, and Sundaresan Jayaraman. 1984\. _The TK!Solver Book: A Guide to Problem-Solving in Science, Engineering, Business, and Education._ Berkeley, CA: Osborne/McGraw-Hill.</reference> <reference>Knuth, Donald E. 1973\. _Fundamental Algorithms._ Volume 1 of _The Art of Computer Programming._ 2nd edition. Reading, MA: Addison-Wesley.</reference> <reference>Knuth, Donald E. 1981\. _Seminumerical Algorithms._ Volume 2 of _The Art of Computer Programming._ 2nd edition. Reading, MA: Addison-Wesley.</reference> <reference>Kowalski, Robert. 1973\. Predicate logic as a programming language. Technical report 70, Department of Computational Logic, School of Artificial Intelligence, University of Edinburgh.</reference> <reference>Kowalski, Robert. 1979\. _Logic for Problem Solving._ New York: North-Holland.</reference> <reference>Lamport, Leslie. 1978\. Time, clocks, and the ordering of events in a distributed system. _Communications of the ACM_ 21(7):558-565.</reference> <reference>Lampson, Butler, J. J. Horning, R. London, J. G. Mitchell, and G. K. Popek. 1981\. Report on the programming language Euclid. Technical report, Computer Systems Research Group, University of Toronto.</reference> <reference>Landin, Peter. 1965\. A correspondence between Algol 60 and Church's lambda notation: Part I. _Communications of the ACM_ 8(2):89-101.</reference> <reference>Lieberman, Henry, and Carl E. Hewitt. 1983\. A real-time garbage collector based on the lifetimes of objects. _Communications of the ACM_ 26(6):419-429.</reference> <reference>Liskov, Barbara H., and Stephen N. Zilles. 1975\. Specification techniques for data abstractions. _IEEE Transactions on Software Engineering_ 1(1):7-19.</reference> <reference>McAllester, David Allen. 1978\. A three-valued truth-maintenance system. Memo 473, MIT Artificial Intelligence Laboratory.</reference> <reference>McAllester, David Allen. 1980\. An outlook on truth maintenance. Memo 551, MIT Artificial Intelligence Laboratory.</reference> <reference>McCarthy, John. 1960\. Recursive functions of symbolic expressions and their computation by machine. _Communications of the ACM_ 3(4):184-195.</reference> <reference>McCarthy, John. 1967\. A basis for a mathematical theory of computation. In _Computer Programing and Formal Systems_, edited by P. Braffort and D. Hirschberg. North-Holland.</reference> <reference>McCarthy, John. 1978\. The history of Lisp. In _Proceedings of the ACM SIGPLAN Conference on the History of Programming Languages._</reference> <reference>McCarthy, John, P. W. Abrahams, D. J. Edwards, T. P. Hart, and M. I. Levin. 1965\. _Lisp 1.5 Programmer's Manual._ 2nd edition. Cambridge, MA: MIT Press.</reference> <reference>McDermott, Drew, and Gerald Jay Sussman. 1972\. Conniver reference manual. Memo 259, MIT Artificial Intelligence Laboratory.</reference> <reference>Miller, Gary L. 1976\. Riemann's Hypothesis and tests for primality. _Journal of Computer and System Sciences_ 13(3):300-317.</reference> <reference>Miller, James S., and Guillermo J. Rozas. 1994\. Garbage collection is fast, but a stack is faster. Memo 1462, MIT Artificial Intelligence Laboratory.</reference> <reference>Moon, David. 1978\. MacLisp reference manual, Version 0\. Technical report, MIT Laboratory for Computer Science.</reference> <reference>Moon, David, and Daniel Weinreb. 1981\. Lisp machine manual. Technical report, MIT Artificial Intelligence Laboratory.</reference> <reference>Morris, J. H., Eric Schmidt, and Philip Wadler. 1980\. Experience with an applicative string processing language. In _Proceedings of the 7th Annual ACM SIGACT/SIGPLAN Symposium on the Principles of Programming Languages._</reference> <reference>Phillips, Hubert. 1934\. _The Sphinx Problem Book_. London: Faber and Faber.</reference> <reference>Pitman, Kent. 1983\. The revised MacLisp Manual (Saturday evening edition). Technical report 295, MIT Laboratory for Computer Science.</reference> <reference>Rabin, Michael O. 1980\. Probabilistic algorithm for testing primality. _Journal of Number Theory_ 12:128-138.</reference> <reference>Raymond, Eric. 1993\. _The New Hacker's Dictionary._ 2nd edition. Cambridge, MA: MIT Press.</reference> <reference>Raynal, Michel. 1986\. _Algorithms for Mutual Exclusion._ Cambridge, MA: MIT Press.</reference> <reference>Rees, Jonathan A., and Norman I. Adams IV. 1982\. T: A dialect of Lisp or, lambda: The ultimate software tool. In _Conference Record of the 1982 ACM Symposium on Lisp and Functional Programming,_ pp. 114-122.</reference> <reference>Rees, Jonathan, and William Clinger (eds). 1991\. The revised![%5E4](../Images/72d61fd46711d939a735c65eb025cbd8.jpg) report on the algorithmic language Scheme. _Lisp Pointers,_ 4(3).</reference> <reference>Rivest, Ronald, Adi Shamir, and Leonard Adleman. 1977\. A method for obtaining digital signatures and public-key cryptosystems. Technical memo LCS/TM82, MIT Laboratory for Computer Science.</reference> <reference>Robinson, J. A. 1965\. A machine-oriented logic based on the resolution principle. _Journal of the ACM_ 12(1):23.</reference> <reference>Robinson, J. A. 1983\. Logic programming—Past, present, and future. _New Generation Computing_ 1:107-124.</reference> <reference>Sagade, Y. 2015\. [SICP exercise 1.14](http://www.ysagade.nl/2015/04/12/sicp-change-growth/) </reference> <reference>Spafford, Eugene H. 1989\. The Internet Worm: Crisis and aftermath. _Communications of the ACM_ 32(6):678-688.</reference> <reference>Steele, Guy Lewis, Jr. 1977\. Debunking the <quote>expensive procedure call</quote> myth. In _Proceedings of the National Conference of the ACM,_ pp. 153-62.</reference> <reference>Steele, Guy Lewis, Jr. 1982\. An overview of Common Lisp. In _Proceedings of the ACM Symposium on Lisp and Functional Programming,_ pp. 98-107.</reference> <reference>Steele, Guy Lewis, Jr. 1990\. _Common Lisp: The Language._ 2nd edition. Digital Press.</reference> <reference>Steele, Guy Lewis, Jr., and Gerald Jay Sussman. 1975\. Scheme: An interpreter for the extended lambda calculus. Memo 349, MIT Artificial Intelligence Laboratory.</reference> <reference>Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R. Crispin, Richard M. Stallman, and Geoffrey S. Goodfellow. 1983\. _The Hacker's Dictionary._ New York: Harper & Row.</reference> <reference>Stoy, Joseph E. 1977\. _Denotational Semantics._ Cambridge, MA: MIT Press.</reference> <reference>Sussman, Gerald Jay, and Richard M. Stallman. 1975\. Heuristic techniques in computer-aided circuit analysis. _IEEE Transactions on Circuits and Systems_ CAS-22(11):857-865.</reference> <reference>Sussman, Gerald Jay, and Guy Lewis Steele Jr. 1980\. Constraints—A language for expressing almost-hierarchical descriptions. _AI Journal_ 14:1-39.</reference> <reference>Sussman, Gerald Jay, and Jack Wisdom. 1992\. Chaotic evolution of the solar system. _Science_ 257:256-262.</reference> <reference>Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak. 1971. Microplanner reference manual. Memo 203A, MIT Artificial Intelligence Laboratory.</reference> <reference>Sutherland, Ivan E. 1963\. SKETCHPAD: A man-machine graphical communication system. Technical report 296, MIT Lincoln Laboratory.</reference> <reference>Teitelman, Warren. 1974\. Interlisp reference manual. Technical report, Xerox Palo Alto Research Center.</reference> <reference>Thatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978. Data type specification: Parameterization and the power of specification techniques. In _Conference Record of the Tenth Annual ACM Symposium on Theory of Computing_, pp. 119-132. Turner, David. 1981\. The future of applicative languages. In _Proceedings of the 3rd European Conference on Informatics,_ Lecture Notes in Computer Science, volume 123\. New York: Springer-Verlag, pp. 334-348.</reference> <reference>Wand, Mitchell. 1980\. Continuation-based program transformation strategies. _Journal of the ACM_ 27(1):164-180.</reference> <reference>Waters, Richard C. 1979\. A method for analyzing loop programs. _IEEE Transactions on Software Engineering_ 5(3):237-247.</reference> <reference>Winograd, Terry. 1971\. Procedures as a representation for data in a computer program for understanding natural language. Technical report AI TR-17, MIT Artificial Intelligence Laboratory.</reference> <reference>Winston, Patrick. 1992\. _Artificial Intelligence_. 3rd edition. Reading, MA: Addison-Wesley.</reference> <reference>Zabih, Ramin, David McAllester, and David Chapman. 1987. Non-deterministic Lisp with dependency-directed backtracking. _AAAI-87_, pp. 59-64.</reference> <reference>Zippel, Richard. 1979\. Probabilistic algorithms for sparse polynomials. Ph.D. dissertation, Department of Electrical Engineering and Computer Science, MIT.</reference> <reference>Zippel, Richard. 1993\. _Effective Polynomial Computation._ Boston, MA: Kluwer Academic Publishers.</reference></references>